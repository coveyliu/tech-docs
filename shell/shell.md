



# 关于 shell

`shell` 有两层含义，1. shell 解释器，2. shell 编程语言



==1、什么是 shell 解释器？==

我们在 `shell` 中输入 `ls . ` ，就会列出当前目录的所有文件，其实，就是 `shell 解释器` 帮我调用了操作系统的 `API`, 

常见的 `shell` 解释器有，`bash`, `sh`



==2、shell 编程语言==

shell 也是一种编程语言，具体是解释型语言





# shell 命令



## 返回值

每一条`shell`命令是有返回值的



## 输入输出重定向

两个问题：

1. 命令从哪里来？
   - 命令来自于键盘输入，键盘就是标准输入
2. 命令的输出一般将其输出到屏幕，屏幕就是标准输出

> *需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。*



```shell
ls . # 将标准输出输出到屏幕

ls . > file # 将标准输出输出到文件

ls . 1> file # 等同于上述命令，只不过 1 通常省去

ls /root/notExists 2> file
```



# shell 脚本



## 格式



包括两部分：1. 声明，2. 代码



声明格式：`#! /bin/bash` 告诉操作系统，执行的时候使用什么解释器。比如：`#! /bin/sh` 使用 `sh` 解释器

```shell
#! /bin/bash
# 注释
ls . && cd /
```





## 接受参数

将参数放在脚本名称后面

用 `$1, $2, $3` 表示接受的第一个、第二个、第三个参数



```shell
# p.sh 内容
#! /bin/bash
echo $1 $2 $3

# 运行
sh p.sh 1 2

# 输出
# 1 2
```





# shell 变量

## 类型

两种类型：1. 数字。2. 字符串



## 定义变量（直接赋值）

无论数字，还是字符串，定义变量时，都可以加引号，或不加引号



```shell
变量名=value # 不加引号
变量名='value' # 加单引号
变量名="value" # 加双引号
```



### 解析变量



==思考下面三个 `echo` 会输出什么？==

```shell
a=192.168.1.2
echo 192.168.1.2 - $a
echo '192.168.1.2 - $a'
echo "192.168.1.2 - $a"

# 输出
192.168.1.2 - 192.168.1.2
192.168.1.2 - $a
192.168.1.2 - 192.168.1.2
```





### 解析命令

下面的命令会输出什么？

```shell
echo today is $(date)
echo "today is $(date)"
echo 'today is $(date)'

# 输出
today is 2022年 01月 24日 星期一 00:42:18 CST
today is 2022年 01月 24日 星期一 00:42:18 CST
today is $(date)
```





### 总结



- 不加引号时，会解析==变量==和==命令==的值
  - 再比如：`echo $(date +%F).tar.gz` 会输出，`2022-01-24.tar.gz`
- 加 ==单引号== 时，会原样输出
- 加 ==双引号== 时，会解析==变量==和==命令==的值





## 将命令的运行结果赋值给变量



两种写法：1. 反引号包裹命令，2. $(命令)



```shell
# 两种写法
a=`date +%F`
b=$(date +%F)
echo $a
echo $b

# 输出
2022-01-24
2022-01-24
```





## 变量子串



变量字串操作：==查看字符长度、提取、删除某些字符、替换某些字符==



提取的时候，只能安装长度提取，不是太方便



![image-20220123172527214](https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123172527214.png)



### 练习 case

```shell
#case01: 查看字符长度
str1='hello, shell'
str2=''
str3=
echo ${#str1}
echo ${#str2}
echo ${#str3} # 可以判断用户输入的变量是否为空

# 输出
# 12
# 0
# 0
```



```shell
# case02: 删除某些字符串
a=abcABC123abcABC
echo ${a#a*C} # 从开头删除最短匹配的字符
echo ${a#a*c}
echo ${a##a*C} # 从开头删除最长匹配的字符
echo ${a##a*c}

# 输出
# 123abcABC
# ABC123abcABC
# 
# ABC

# % 和 # 用法是一样的，这里就不写了
# 目前，我知道的子串模式匹配只有 *
```



```shell
# case03 替换
# 将 a 用 A 替换
str='str a, str a'
echo ${str/a/A} # 一个“/”表示替换匹配的第一个字符串
echo ${str//a/A} # 两个“/”表示替换匹配的所有字符串

# 输出
# str A, str a
# str A, str A
```



# 数值运算



## 整数运算



### (())



==(( ... )) 双括号里面只能运算数值==



```shell
echo $((1-1))
echo $((1-'a'))
echo $((1-"a"))
echo $((1.1 - 2)) # (()) 只能进行整数运算，有专门的用于小数运算的命令

# 输出
# 0
# -bash: 1-'a': 语法错误: 期待操作数 （错误符号是 "'a'"）
# -bash: 1-"a": 语法错误: 期待操作数 （错误符号是 ""a""）
# -bash: 1.1 - 2: 语法错误: 无效的算术运算符 （错误符号是 ".1 - 2"）
```





#### 运算后赋值

```shell
zero=$((1-1)) # 将 1-1 运算后的结果赋给变量 zero
echo $zero # 输出变量的值

# 输出
# 0
```





####  ++ --

```shell
a=1
echo $((a++)) # 先输出 a 的值
echo $a # a已经加了 1

# 输出
# 1
# 2
```



**==在 (()) 中引用变量时，可以不加 `$` 符号==**









## expr



expr 是 evaluate expressions 的缩写



```shell
expr 1 + 1
expr 1 \* 2

# 输出
# 2
# 
```



==注意：==

1. 算符及用于计算的数字左右都至少有一个空格，否则会报错
2. 使用乘号时，必须用反斜线屏蔽其特定含义，因为Shell可能会误解星号的含义。





### 判断一个变量是否为整数



在Shell编程里，由于函数库很少，所以判断字符串是否为整数就不是一件很容易的事情



解题思路：用以expr做计算时变量或字符串必须是整数的规则，把一个变量或字符串和一个已知的整数（非0）相加，看命令返回的值是否为0。

- 如果为0，就认为做加法的变量或字符串为整数，
- 否则就不是整数



```shell
# 判断变量是否为整数
i1=1
i2='a'
expr $i1 + 1 > /dev/null 2>&1 # 将错误输出、正常输出输出到 /dev/null 中
echo $? # $? 读取上一个命令的返回值
expr $i2 + 1 > /dev/null 2>&1
echo $?

# 输出
# 0
# 2
```







## 小数运算



- [ ] //todo









# 条件测试



<img src="https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123180617801.png" alt="image-20220123180617801" style="zoom: 80%;" />



**==虽然有四种写法，但是推荐使用 `[]` 或 `[[]]` 两种写法==**





## [ ] VS [[ ]]



**这里先列出两者的区别**



1. &&、||、＞、＜等操作符可以应用于[[]]中，但不能应用于[]中，
2. 在[]中一般用-a、-o、-gt（用于整数）、-lt（用于整数）代替上述操作符





##  [ <表达式> ]



格式：

<img src="https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123181031498.png" alt="image-20220123181031498" style="zoom:80%;" />



```shell
# case：判断是不是要给文件
[ -f ./fileNotExists.txt ] && echo 1 || echo 0 # 是文件则输出 1，否则输出 0
touch fileNotExists.txt
[ -f ./fileNotExists.txt ] && echo 1 || echo 0

# 输出
# 0
# 1
```



### 和变量一起使用



```shell
i=1
[ "$i" -gt 2 ] && echo 1 || echo 0
[ $i -gt 2 ] && echo 1 || echo 0

# 输出
# 0
# 0
```





## [[ <表达式> ]]



- [ ] todo





## 替换 if



一般都会这样，替换 if



{ } 输出多个命令



```shell
[ 条件1 ] && {
	命令1
	命令2
	命令3
} || {
	命令1
	命令2
	命令3
}

# 相当于
if 条件
then
	命令1
	命令2
	命令3
else
	命令1
	命令2
fi
```





## 文件测试



![image-20220123181753540](https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123181753540.png)



==一般判断是不是目录，是不是文件、是否存在==



### 和变量一起使用



```shell
f=a.txt
[ -f $f ] && echo 1 || echo 0
mkdir d1
[ -d $d1 ] && echo 1 || echo 0

# 输出
# 0
# 1
```



## 字符串

| 表达式                 | 说明         |
| ---------------------- | ------------ |
| -z "字符串"            | 长度是零     |
| -n "字符串"            | 长度不为零   |
| "字串串1" == "字符串2" | 字符串相同   |
| "字串串1" != "字符串2" | 字符串不相同 |



==注意、注意、一定要注意，说三遍！==

1. 一定要将字符串加双引号之后再进行比较。如`[ -n"$myvar" ]`
2. 比较符号（例如=和！=）的两端一定要有空格





==1、字符串不加引号可能带来的问题==

```shell
var=""
[ -n $var ] && echo 1 || echo 0 # 判断错误
[ -n "$var" ] && echo 1 || echo 0
[ -z "$var" ] && echo 1 || echo 0

# 输出
# 1
# 0
# 1
```



==2、等号两端没有空格带来的问题==

```shell
[ "abc"="1" ] && echo 1 || echo 0 # 判断错误
[ "abc" = "1" ] && echo 1 || echo 0

# 输出
# 1 
# 0 
```





## 整数测试



==`[ ]` 中使用的运算符和 `[[]]` 不一样==

==也可以在[[]]中使用包含“-gt”和“-lt”的符号，但是不建议这样使用==



![image-20220123183716157](https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123183716157.png)



## 逻辑操作符







![image-20220123183928106](https://typora-covey.oss-cn-shanghai.aliyuncs.com/img/image-20220123183928106.png)



### case: 使用多个[]号



```shell
# 多个条件既可以在 [] 内部使用 -a, -o, 也可以在 [] 外部使用 &&, ||

# case: 有一个小于 10 就行
m=9; n=19
[ $m -lt 10 -o $n -lt 10 ] && echo 1 || echo 0
[ $m -lt 10 ] || [ $n -lt 10 ] && echo 1 || echo 0

# 输出
# 1
# 1
```



# if







# shell 内置命令



`学一下几个 shell 内置的命令`



## read



























