# 分类

```
1. mysql 为什么要提供锁？
2. mysql 锁的分类？
3. 你觉得 mysql 的锁复杂吗？你平时是如何利用锁的？
```



Mysql 也是为了处理并发访问设计的锁。

锁分类：

1. 按照加锁范围：全局锁、表锁、行锁
2. 互斥：共享锁 `s lock`, 排它锁 `x lock`

mysql 的锁很复杂。平时关注过行锁，但是也没用过（好吧，我没利用过锁）



# 加锁范围



## 全局锁



- 全局锁是对整个数据库实例加锁
- 全局锁的典型使用场景是，做全库逻辑备份（注意是全库，也就是所有表）
- 加锁命令：Flush tables with read lock (FTWRL)。加锁后，整个mysql实例处于只读状态
- 另一种让全库只读方式是设置  `set global readonly=true`。但是，全库备份时，不建议这样使用



## 表锁

```
1. 表锁也分两类
```



**表锁**

- 表级别的锁也分两类：1. 表锁，2：MDL (元数据锁 meta data lock)

- 表锁：
  - 加锁：` lock tables … read/write`。举例：`lock tables t1 read, t2 write`
  - 释放锁：1. 主动释放（`unlock tables`)，2. 使其自动释放（客户端断开的时候自动释放）
- `innodb` 支持这种表锁吗？



**MDL**

- MDL 不需要显式使用，在访问一个表的时候会被自动加上
  - 一个表做增删改查操作的时候，加 MDL 读锁。（ CURD 的时候也加？）
  - 表做结构变更操作的时候，加 MDL 写锁
- MDL 什么时候释放？
  - 事务结束后释放
- MDL 的作用是，保证读写的正确性
  - 读写不正确的例子：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
  - Mysql 5.5 新增
- MDL 读锁 和 写锁
  - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
  - 读写锁之间、写锁之间是互斥的。所以，一个线程给一个张表添加字段的时候，其它线程不能添加字段，也不能 CURD
- MDL 可能造成的事故
  1. 给一个小表加个字段，整个库 2s 内不能读写。（2s 是我杜撰的，实际情况可能更长。所以，**DDL 的时候一定要小心**）



给一个小表加个字段导致整个库不能读写实操：

<img width='70%' src='https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220630000027.png'>



## 行锁

```
1. 行锁是由引擎实现的，innodb就支持行锁，myisam 不支持行锁
2. myisam 不支持行锁，那么它是通过表锁控制并发，并发度低
```



- 行锁是由引擎实现的，innodb就支持行锁，myisam 不支持行锁
- myisam 不支持行锁，那么它是通过表锁控制并发，并发度低（一次只能有一个线程修改表中的数据）
- 加锁，解锁，锁等待时间（锁三要素）
  - 加锁。在一个事务中，是需要的时候才加锁，比如事务的的 `select` 有可能就不加锁，`update` 需要加锁
  - 解锁。事务提交后，才解锁
  - 锁等待时间。释放锁时间 - 获取锁时间



### 死锁

```
1. 举一个死锁的例子
2. 死锁的解决办法？
3. innodb 是如何检测死锁的？mysql 5 和 mysql 8关于死锁检测的区别是什么？
3. 热点行数据更新会造成什么问题？原因是因为啥？怎么解决？
```



死锁的解决办法有两个：1. 设置锁等待超时，2. 设置死锁自动检测

- 设置锁等待超时后，假如发生死锁，innodb 会回滚其中一个事务。相应的超时设置变量是：`innodb_lock_wait_timeout`
- 设置死锁检测后，当某一个事务需要等待锁时，它会检测别的事务的锁持有情况，当出现死锁的时候会回滚其中一个事务。由变量` innodb_deadlock_detect` 设置为 `on` 即可开启死锁检测。关于死锁检测，可以看下官网：https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html

不同版本的死锁检测对比。Mysql 5 没有`innodb_deadlock_detect` 这个设置，Mysql 8 有，并且是默认开启的



热点行数据更新会有怎样的问题？这个问题的原因是什么？怎么解决?

- 产生的问题：TPS 低，CPU 利用率高

- 死锁检测耗费 CPU

- 解决方式？

  1. 修改 Mysql 源码

  2. 将该热点行分成逻辑上的多行



**Mysql 5 VS Mysql 8**

```mysql
mysql> show variables like 'version';
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| version       | 8.0.27 |
+---------------+--------+
1 row in set (0.06 sec)

mysql> show variables like 'innodb_deadlock_detect';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_deadlock_detect | ON    |
+------------------------+-------+
1 row in set (0.07 sec)
mysql> show variables like 'version';
+---------------+------------+
| Variable_name | Value      |
+---------------+------------+
| version       | 5.6.16-log |
+---------------+------------+
1 row in set (0.07 sec)

mysql> show variables like 'innodb_lock_wait_timeout';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_lock_wait_timeout | 50    |
+--------------------------+-------+
1 row in set (0.06 sec)

mysql> show variables like 'innodb_deadlock_detect';
Empty set
```

