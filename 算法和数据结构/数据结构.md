

# 数据结构和算法

- 什么是数据结构？
  - 存储数据的介质。数据结构有不同的形式，比如：线性、非线性
- 特定的数据结构，有特定的算法，比如二分查找适用于数组，但不适用链表



- 分类
  - 线性表（linear list)
  - 非线性



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505134139.jpg)



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505134152.jpg)



# 线性（linear list)





## 数组



- 什么是数组
  - 连续内存空间存储相同数据类型的一种线性数据结构





### 如何实现随机访问？



比如，`int[] a = new int[10]` ，变量 `a` 存储的是数组的首地址，那么访问任意下标（没有下标越界的情况下）位置就可以用 `[i]_address = base_address + i * data_type_size`, `int` 4 个字节，只需要直接访问其地址就可以了。所以，这种按下标访问数组元素的操作的时间复杂度 `O(1)`





### 低效的插入和删除



- 插入、删除操作
  - 尾部插入、删除操作，时间复杂度 `O(1)`
  - 非尾部插入、删除
    - 数组内存空间是连续的，插入、删除操作涉及到`数据移动`
    - 最坏时间复杂度 `O(n)`



## 链表



### 基本概念



- 节点
  - 头节点、尾节点（这两个节点要特别注意）
- 指针（**指针：存储的相邻节点的内存地址，通过指针，可以访问其它节点**）
  - 前驱指针（指向上一个节点）
  - 后继指针（指向下一个节点）





### 常见链表



- 常见链表
  - 单链表
  - 循环链表
  - 双向链表
  - 双向循环链表





![03jpg](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153343.jpg)



![04](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153459.jpg)



![05](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153531.jpg)



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153539.jpg)







### 链表 VS 数组性能大比拼



- 什么时候使用数组？
  - CPU 预读
    - （实际上，我也不是很理解）
    - 我的理解：当 cpu 指令访问 数组时，会将数组中所有元素读取到缓存中
    - 可以这样理解 `int[] a `, `ArrayList<Integar> b`, `a` 在 cpu 缓存中， `b` 在内存中
  - 如果你是一个底层程序开发者，多会用到数组
    - 追求极致的性能
- 链表 vs 数组

|              | 链表                                         | 数组 |
| ------------ | -------------------------------------------- | ---- |
| 存储数据限制 | 不能存储基本数据类型（`int, byte, short ...` | 能   |







### 如何写好链表代码



**技巧一：理解指针或引用的含义**



> 1. 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
>
> 
>
> 2. 用好指针是写好链表代码的关键

​	

一句话，指针存储节点内存地址，指针的目的是：找到其它节点



链表操作：删除、添加元素，就是改变指针指向。用好指针是写好链表代码的关键





**技巧二：警惕指针丢失和内存泄漏**



```java
p->next = x;  // 将 p 的 next 指针指向 x 结点；
x->next = p->next;  // 将 x 的结点的 next 指针指向 b 结点
```

p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x->next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。







**技巧四：重点留意边界条件处理**

可以使用下面的边界条件检查链表代码：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？









**技巧五：举例画图，辅助思考**



**技巧六：多写多练，没有捷径**













### 练习 - 使用列表实现 LRU 缓存淘汰算法





### 练习 - 链表常见操作 



- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点





## 栈



- 两个概念：栈顶、栈底
- 操作受到限制：只能操作栈顶元素
- 先进后出，后进先出





### 如何实现一个栈？



数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，叫作**链式栈**。



**基于数组实现的栈**

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           // 栈的大小
 
  // 初始化数组，申请一个大小为 n 的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }
 
  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回 false，入栈失败。
    if (count == n) return false;
    // 将 item 放到下标为 count 的位置，并且 count 加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回 null
    if (count == 0) return null;
    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```



入栈（`push`)，出栈（`pop`) 操作的时间复杂度都是 `O(1)`, 空间复杂度也是 `O(1)`。这个栈需要的空间不是 `n` 吗？为啥空间复杂度是 `O(1)`? 空间复杂度是指，算法执行过程中需要的额外的空间，`push`, `pop` 操作并不需要随着数据规模的增加需要其它额外空间



`new String[n]`这 n 个空间是必须的，无法省掉





### 支持动态扩容的顺序栈



支持动态扩容的顺序栈，我们平时开发中并不常用到。







### 应用



- 浏览器前进后退功能





**浏览器前进、后退**

这个功能的实现用到了两个栈。每浏览一个页面，将该页面放入**栈1**，后退操作时，将**栈1** 的栈顶元素放入**栈2**

前进操作时，访问**栈2**



<img src="https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505171624.png" alt="image-20220505171624437" style="zoom:33%;" />

感觉用双向链表实现前进、后退也行





## 队列





### 理解队列



> 看到一种数据结构，应该
>
> 1. 这种数据结构重要的位置
> 2. 这种数据结构支持的操作



- 队列重要的位置
  - 队头、队尾
- 支持的操作
  - 入队（`enqueue`），出队（ `dequeue`)
  - 可以的操作有限

![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220506111712.jpg)





### 如何实现一个队列

和栈一样，可以用数组和链表实现，名称叫法也一样，比如用数组实现的栈，叫做**顺序栈**，链表实现的栈叫做**链式栈**

对于队列，用数组实现的队列，叫做**顺序队列**，链表实现的队列，叫做**链式队列**



**数组实现**

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;
 
  // 申请一个大小为 capacity 的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }
 
  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }
 
  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了
    String ret = items[head];
    ++head;
    return ret;
  }
}
```





### 心得

看了别人用数组实现栈、队列后的心得



- 数组只是用来存储数据的
- 数组只需要通过下标存取元素 `int[] a = new int[10]; int e = a[i]; a[i] = newE`
- 要想实现栈存、取元素从栈顶操作，队列在头部存元素、从尾部取元素，需要额外的动作
  - 栈需要一个指针()`count`)指示存取位置
  - 队列需要两个指针（`head`, `tail`)，指示头部位置、尾部位置
  - 为什么要额外添加指针？ 个人认为，这是跟数组通过下标存取元素有关
  - 关于指针
    - 此指针指示数组的下标
    - 而非链表的指针（存储的是其它节点的位置）



**思考**

根据链表的操作特点，怎么实现栈和队列呢？





### 常见队列



- 循环队列
- 阻塞队列





### 应用



- 线程池（多个线程 + 任务）

  - 保存任务就是用的队列

    



## 递归





### 什么问题适合用递归





### 如何写好递归





### 递归需要注意的地方



1. 递归深度过大，导致堆栈溢出
2. 避免重复计算



# 非线性表