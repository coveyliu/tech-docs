
<!-- TOC -->

- [1. 数据结构和算法](#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95)
- [2. 线性（linear list](#2-%E7%BA%BF%E6%80%A7linear-list)
    - [2.1. 数组](#21-%E6%95%B0%E7%BB%84)
        - [2.1.1. 如何实现随机访问？](#211-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE)
        - [2.1.2. 低效的插入和删除](#212-%E4%BD%8E%E6%95%88%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4)
    - [2.2. 链表](#22-%E9%93%BE%E8%A1%A8)
        - [2.2.1. 基本概念](#221-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
        - [2.2.2. 常见链表](#222-%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8)
        - [2.2.3. 链表 VS 数组性能大比拼](#223-%E9%93%BE%E8%A1%A8-vs-%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC)
        - [2.2.4. 如何写好链表代码](#224-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81)
        - [2.2.5. 练习 - 使用列表实现 LRU 缓存淘汰算法](#225-%E7%BB%83%E4%B9%A0---%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0-lru-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
        - [2.2.6. 练习 - 链表常见操作](#226-%E7%BB%83%E4%B9%A0---%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C)
    - [2.3. 栈](#23-%E6%A0%88)
        - [2.3.1. 如何实现一个栈？](#231-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88)
        - [2.3.2. 支持动态扩容的顺序栈](#232-%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88)
        - [2.3.3. 应用](#233-%E5%BA%94%E7%94%A8)
    - [2.4. 队列](#24-%E9%98%9F%E5%88%97)
        - [2.4.1. 理解队列](#241-%E7%90%86%E8%A7%A3%E9%98%9F%E5%88%97)
        - [2.4.2. 如何实现一个队列](#242-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97)
        - [2.4.3. 心得](#243-%E5%BF%83%E5%BE%97)
        - [2.4.4. 常见队列](#244-%E5%B8%B8%E8%A7%81%E9%98%9F%E5%88%97)
        - [2.4.5. 应用](#245-%E5%BA%94%E7%94%A8)
    - [2.5. 递归](#25-%E9%80%92%E5%BD%92)
        - [2.5.1. 什么问题适合用递归](#251-%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%80%82%E5%90%88%E7%94%A8%E9%80%92%E5%BD%92)
        - [2.5.2. 如何写好递归](#252-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%80%92%E5%BD%92)
        - [2.5.3. 递归需要注意的地方](#253-%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9)
- [3. 非线性表](#3-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8)

<!-- /TOC -->
# 1. 数据结构和算法
<a id="markdown-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" name="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"></a>

- 什么是数据结构？
  - 存储数据的介质。数据结构有不同的形式，比如：线性、非线性
- 特定的数据结构，有特定的算法，比如二分查找适用于数组，但不适用链表



- 分类
  - 线性表（linear list)
  - 非线性



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505134139.jpg)



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505134152.jpg)



# 2. 线性（linear list)
<a id="markdown-%E7%BA%BF%E6%80%A7%EF%BC%88linear-list" name="%E7%BA%BF%E6%80%A7%EF%BC%88linear-list"></a>





## 2.1. 数组
<a id="markdown-%E6%95%B0%E7%BB%84" name="%E6%95%B0%E7%BB%84"></a>



- 什么是数组
  - 连续内存空间存储相同数据类型的一种线性数据结构





### 2.1.1. 如何实现随机访问？
<a id="markdown-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F" name="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9F"></a>



比如，`int[] a = new int[10]` ，变量 `a` 存储的是数组的首地址，那么访问任意下标（没有下标越界的情况下）位置就可以用 `[i]_address = base_address + i * data_type_size`, `int` 4 个字节，只需要直接访问其地址就可以了。所以，这种按下标访问数组元素的操作的时间复杂度 `O(1)`





### 2.1.2. 低效的插入和删除
<a id="markdown-%E4%BD%8E%E6%95%88%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4" name="%E4%BD%8E%E6%95%88%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"></a>



- 插入、删除操作
  - 尾部插入、删除操作，时间复杂度 `O(1)`
  - 非尾部插入、删除
    - 数组内存空间是连续的，插入、删除操作涉及到`数据移动`
    - 最坏时间复杂度 `O(n)`



## 2.2. 链表
<a id="markdown-%E9%93%BE%E8%A1%A8" name="%E9%93%BE%E8%A1%A8"></a>



### 2.2.1. 基本概念
<a id="markdown-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" name="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"></a>



- 节点
  - 头节点、尾节点（这两个节点要特别注意）
- 指针（**指针：存储的相邻节点的内存地址，通过指针，可以访问其它节点**）
  - 前驱指针（指向上一个节点）
  - 后继指针（指向下一个节点）





### 2.2.2. 常见链表
<a id="markdown-%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8" name="%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8"></a>



- 常见链表
  - 单链表
  - 循环链表
  - 双向链表
  - 双向循环链表





![03jpg](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153343.jpg)



![04](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153459.jpg)



![05](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153531.jpg)



![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505153539.jpg)







### 2.2.3. 链表 VS 数组性能大比拼
<a id="markdown-%E9%93%BE%E8%A1%A8-vs-%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC" name="%E9%93%BE%E8%A1%A8-vs-%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC"></a>



- 什么时候使用数组？
  - CPU 预读
    - （实际上，我也不是很理解）
    - 我的理解：当 cpu 指令访问 数组时，会将数组中所有元素读取到缓存中
    - 可以这样理解 `int[] a `, `ArrayList<Integar> b`, `a` 在 cpu 缓存中， `b` 在内存中
  - 如果你是一个底层程序开发者，多会用到数组
    - 追求极致的性能
- 链表 vs 数组

|              | 链表                                         | 数组 |
| ------------ | -------------------------------------------- | ---- |
| 存储数据限制 | 不能存储基本数据类型（`int, byte, short ...` | 能   |







### 2.2.4. 如何写好链表代码
<a id="markdown-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81" name="%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81"></a>



**技巧一：理解指针或引用的含义**



> 1. 将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
>
> 
>
> 2. 用好指针是写好链表代码的关键

​	

一句话，指针存储节点内存地址，指针的目的是：找到其它节点



链表操作：删除、添加元素，就是改变指针指向。用好指针是写好链表代码的关键





**技巧二：警惕指针丢失和内存泄漏**



```java
p->next = x;  // 将 p 的 next 指针指向 x 结点；
x->next = p->next;  // 将 x 的结点的 next 指针指向 b 结点
```

p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x->next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。







**技巧四：重点留意边界条件处理**

可以使用下面的边界条件检查链表代码：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？









**技巧五：举例画图，辅助思考**



**技巧六：多写多练，没有捷径**













### 2.2.5. 练习 - 使用列表实现 LRU 缓存淘汰算法
<a id="markdown-%E7%BB%83%E4%B9%A0---%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0-lru-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95" name="%E7%BB%83%E4%B9%A0---%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0-lru-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"></a>





### 2.2.6. 练习 - 链表常见操作
<a id="markdown-%E7%BB%83%E4%B9%A0---%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" name="%E7%BB%83%E4%B9%A0---%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"></a>



- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点





## 2.3. 栈
<a id="markdown-%E6%A0%88" name="%E6%A0%88"></a>



- 两个概念：栈顶、栈底
- 操作受到限制：只能操作栈顶元素
- 先进后出，后进先出





### 2.3.1. 如何实现一个栈？
<a id="markdown-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88%EF%BC%9F" name="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88%EF%BC%9F"></a>



数组实现的栈，我们叫作**顺序栈**，用链表实现的栈，叫作**链式栈**。



**基于数组实现的栈**

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           // 栈的大小
 
  // 初始化数组，申请一个大小为 n 的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }
 
  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回 false，入栈失败。
    if (count == n) return false;
    // 将 item 放到下标为 count 的位置，并且 count 加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回 null
    if (count == 0) return null;
    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```



入栈（`push`)，出栈（`pop`) 操作的时间复杂度都是 `O(1)`, 空间复杂度也是 `O(1)`。这个栈需要的空间不是 `n` 吗？为啥空间复杂度是 `O(1)`? 空间复杂度是指，算法执行过程中需要的额外的空间，`push`, `pop` 操作并不需要随着数据规模的增加需要其它额外空间



`new String[n]`这 n 个空间是必须的，无法省掉





### 2.3.2. 支持动态扩容的顺序栈
<a id="markdown-%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88" name="%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88"></a>



支持动态扩容的顺序栈，我们平时开发中并不常用到。







### 2.3.3. 应用
<a id="markdown-%E5%BA%94%E7%94%A8" name="%E5%BA%94%E7%94%A8"></a>



- 浏览器前进后退功能





**浏览器前进、后退**

这个功能的实现用到了两个栈。每浏览一个页面，将该页面放入**栈1**，后退操作时，将**栈1** 的栈顶元素放入**栈2**

前进操作时，访问**栈2**



<img src="https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220505171624.png" alt="image-20220505171624437" style="zoom:33%;" />

感觉用双向链表实现前进、后退也行





## 2.4. 队列
<a id="markdown-%E9%98%9F%E5%88%97" name="%E9%98%9F%E5%88%97"></a>





### 2.4.1. 理解队列
<a id="markdown-%E7%90%86%E8%A7%A3%E9%98%9F%E5%88%97" name="%E7%90%86%E8%A7%A3%E9%98%9F%E5%88%97"></a>



> 看到一种数据结构，应该
>
> 1. 这种数据结构重要的位置
> 2. 这种数据结构支持的操作



- 队列重要的位置
  - 队头、队尾
- 支持的操作
  - 入队（`enqueue`），出队（ `dequeue`)
  - 可以的操作有限

![](https://blog-bt.oss-cn-beijing.aliyuncs.com/1/20220506111712.jpg)





### 2.4.2. 如何实现一个队列
<a id="markdown-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97" name="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"></a>

和栈一样，可以用数组和链表实现，名称叫法也一样，比如用数组实现的栈，叫做**顺序栈**，链表实现的栈叫做**链式栈**

对于队列，用数组实现的队列，叫做**顺序队列**，链表实现的队列，叫做**链式队列**



**数组实现**

```java
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;
 
  // 申请一个大小为 capacity 的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }
 
  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }
 
  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了
    String ret = items[head];
    ++head;
    return ret;
  }
}
```





### 2.4.3. 心得
<a id="markdown-%E5%BF%83%E5%BE%97" name="%E5%BF%83%E5%BE%97"></a>

看了别人用数组实现栈、队列后的心得



- 数组只是用来存储数据的
- 数组只需要通过下标存取元素 `int[] a = new int[10]; int e = a[i]; a[i] = newE`
- 要想实现栈存、取元素从栈顶操作，队列在头部存元素、从尾部取元素，需要额外的动作
  - 栈需要一个指针()`count`)指示存取位置
  - 队列需要两个指针（`head`, `tail`)，指示头部位置、尾部位置
  - 为什么要额外添加指针？ 个人认为，这是跟数组通过下标存取元素有关
  - 关于指针
    - 此指针指示数组的下标
    - 而非链表的指针（存储的是其它节点的位置）



**思考**

根据链表的操作特点，怎么实现栈和队列呢？





### 2.4.4. 常见队列
<a id="markdown-%E5%B8%B8%E8%A7%81%E9%98%9F%E5%88%97" name="%E5%B8%B8%E8%A7%81%E9%98%9F%E5%88%97"></a>



- 循环队列
- 阻塞队列





### 2.4.5. 应用
<a id="markdown-%E5%BA%94%E7%94%A8" name="%E5%BA%94%E7%94%A8"></a>



- 线程池（多个线程 + 任务）

  - 保存任务就是用的队列

    



## 2.5. 递归
<a id="markdown-%E9%80%92%E5%BD%92" name="%E9%80%92%E5%BD%92"></a>

> 争哥说：递归和动态规划最难



### 2.5.1. 什么问题适合用递归
<a id="markdown-%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%80%82%E5%90%88%E7%94%A8%E9%80%92%E5%BD%92" name="%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%80%82%E5%90%88%E7%94%A8%E9%80%92%E5%BD%92"></a>

1. 一个问题可以分解为一个或多个子问题，这些子问题又可以向拆分为相同的子问题
2. 这些子问题的解法相同



比如：



### 2.5.2. 如何写好递归
<a id="markdown-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%80%92%E5%BD%92" name="%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E9%80%92%E5%BD%92"></a>

所有的递归问题都可以用递推公式解决



如何写好递归？

1. 找出递推公式
2. 找出递归终止条件





### 2.5.3. 递归需要注意的地方
<a id="markdown-%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9" name="%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"></a>

1. 递归深度过大，导致堆栈溢出
2. 避免重复计算



说下，递归的优缺点

- 优点
  - 解法简单
- 缺点
  - 递归深度过大，会倒是堆栈溢出







# 3. 非线性表
<a id="markdown-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8" name="%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8"></a>
