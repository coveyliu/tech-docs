
<!-- TOC -->

- [1. 时间复杂度](#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
- [2. 空间复杂度](#2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

<!-- /TOC -->
学好复杂度分析

- 能够知道算法的优劣
- 这部分内容很重要



# 1. 时间复杂度
<a id="markdown-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" name="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"></a>

- 什么是时间复杂度？
  - 代码执行耗时。（随着数据规模的增加，代码执行耗时）
  - 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**



- 常见的时间复杂度量级
  - O(1), O(log^n^), O(n), O(nlog^n^), O(n^2^) （从优到劣）
- 时间复杂度分析
  - 加法法则：O(f(n))  + O(g(n))  = O(max(f(n), g(n))) 
  - 乘法法则：O(f(n)) * O(g(n)) = O(f(n)*g(n))
  - O(f(m)）) + O(g(n)) = O(f(m) +  g(n))



**加法法则**

```java
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }
 
   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```



计算 `sum_1` ，与数据规模 `n` 无关

计算`sum_2`，`O(n)`, 计算 `sum_3`， `O(n2)`。所以，最终的时间复杂度是 `max(O(n), O(n2)) = O(n2)`,



**乘法法则**：**嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**



```java
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```



我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。



# 2. 空间复杂度
<a id="markdown-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" name="%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"></a>



执行算法时，额外需要的空间，就是空间复杂度

