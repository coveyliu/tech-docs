# 创建型



## 简单工厂

- 特征
  1. 类命名： `xxxFactory`, `xxxS`
  2. 只有一个方法：`createXXX`， `newXXX`, `getXXX`



==方式1==

```java
public class RuleConfigParserFactory{
    
    public static IRuleConfigParser createParser(String configFormat){
        IRuleConfigParser parser = null;
        
        if("json".equalsIgnoreCase(configFormat)){
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)){
            parser = new XmlRuleConfigParser()
        }else if ("yaml".equalsIgnoreCase(configFormat)){
            parser = new YamlRuleConfigParser()
        } else if ("properties".equalsIgnoreCase(configFormat)){
            parser = new PropertiesRuleConfigParser()
        }
        return parser;
    }
}
```



==方式2==

```java
public class RuleConfigParserFactory{
    
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();
    
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    
    public static IRuleConfigParser createParser(String configFormat){
        if (configFormat == null || configFormat.isEmpty()){
            return null;
        }
        return cachedParsers.get(configFormat.toLowerCase());
    }
}
```





## 工厂方法模式

- 使用步骤：

  1. 创建工厂接口
  2. 创建不同工厂实现
  3. 创建工厂的工厂类
  4. 从工厂类获取想要的工厂 -> 获取对象

- 思考：

  1. 什么时候用简单工厂、什么时候用工厂方法？

     - 简单工厂：创建对象简单，比如：直接new

     - 工厂方法
       - 创建对象过程复杂，比如：组合其它对象、初始化工作
       - 这样的复杂创建过程，用简单工厂，那么简单工厂中的代码会非常多



```java
// step 1
public interface IRuleConfigParserFactory{
    IRuleConfigParser createParser();
}

// step2
public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory{
    
    @Override
    public IRuleConfigParser createParser(){
       return new JsonRuleConfigParser(); 
    }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory{
    
    @Override
    public IRuleConfigParser createParser(){
       return new XmlRuleConfigParser(); 
    }
}

// step 3: // 工厂类只包含了方法，可以直接拿来用，不需要每次都创建工厂
public class RuleConfigParserFactoryMap{
    
    private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();
    
    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    }
    
    public static IRuleConfigParserFactory createParserFactory(String configFormat){
        if (configFormat == null || configFormat.isEmpty()){
            return null;
        }
        return cachedFactories.get(configFormat.toLowerCase());
    }
}
```





## 抽象工厂模式

- 特征：
  1. 有工厂接口，有工厂实现
  2. 工厂接口可以定义多个获取对象的方法



例子1：

```java
public interface AopProxyFactory {

	/**
	 * Create an {@link AopProxy} for the given AOP configuration.
	 * @param config the AOP configuration in the form of an
	 * AdvisedSupport object
	 * @return the corresponding AOP proxy
	 * @throws AopConfigException if the configuration is invalid
	 */
	AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException;

}

// 实现
ublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

	@Override
	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		// 省略
    }

}
```





# 行为型



## 责任链



- 所有的处理动作放在一个链子上，被处理的内容沿着链子走动
- 行为：
  1. 链子上的每个步骤都走了一遍
  2. 被链子上的一个成员处理后，就算完成
- 存放 chain 上的 handler、filter：
  1. 链表
  2. 数组、列表



例子1：

```java

```



例子2：

```java

```

